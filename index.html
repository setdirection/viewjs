      <!DOCTYPE html>
      <html>
        <head>
          <title>jQuery View</title>
          <link rel="stylesheet" media="screen" href="screen.css"/>
        </head>
        <body>
          <h1 id='jquery_view'>jQuery View</h1>

<h2 id='new_classobject_attributes__instance'>new Class<em>([Object attributes]) -&gt; instance</em></h2>

<pre><code>var instance = new MyView({
  key: &#39;value&#39;
});
document.body.appendChild(instance.element());</code></pre>

<h1 id='class_methods'>Class Methods</h1>

<h2 id='classinstance__instance'>Class.instance<em>() -&gt; instance</em></h2>

<h2 id='classbindstring_event_name_function_callback_object_context__function'>Class.bind<em>(String event_name, Function callback [,Object context]) -&gt; Function</em></h2>

<h2 id='classonestring_event_name_function_callback_object_context__function'>Class.one<em>(String event_name, Function callback [,Object context]) -&gt; Function</em></h2>

<h2 id='classunbindstring_event_name_function_callback_object_context__null'>Class.unbind<em>([String event_name] [,Function callback] [,Object context]) -&gt; null</em></h2>

<h2 id='classtriggerstring_event_name__array_or_false'>Class.trigger<em>(String event_name) -&gt; Array or false</em></h2>

<h2 id='classreadyfunction_callback_object_context__function'>Class.ready<em>(Function callback [,Object context]) -&gt; Function</em></h2>

<h1 id='instance_methods'>Instance Methods</h1>

<h2 id='instancegetstring_key__mixed'>instance.get<em>(String key) -&gt; mixed</em></h2>

<h2 id='instancesetstring_keymixed_value__mixed'>instance.set<em>(String key,mixed value) -&gt; mixed</em></h2>

<h2 id='instanceelement__elementinstanceelementelement_element__element'>instance.element<em>() -&gt; Element</em><br />instance.element<em>(Element element) -&gt; Element</em></h2>

<p>Set or get the outermost element in the view. The element should only be set from within the view constructor.</p>

<pre><code>var instance = new MyView(function(){
  return this.div();
});
instance.element().tagName == &#39;div&#39;</code></pre>

<h2 id='instancebindstring_event_name_function_callback_object_context__function'>instance.bind<em>(String event_name, Function callback [,Object context]) -&gt; Function</em></h2>

<h2 id='instanceonestring_event_name_function_callback_object_context__function'>instance.one<em>(String event_name, Function callback [,Object context]) -&gt; Function</em></h2>

<h2 id='instanceunbindstring_event_name_function_callback_object_context__null'>instance.unbind<em>([String event_name] [,Function callback] [,Object context]) -&gt; null</em></h2>

<h2 id='instancereadyfunction_callback_object_context__function'>instance.ready<em>(Function callback [,Object context]) -&gt; Function</em></h2>

<h2 id='instancetriggerstring_event_name__array_or_false'>instance.trigger<em>(String event_name) -&gt; Array or false</em></h2>

<h1 id='properties'>Properties</h1>

<h2 id='viewfn__object'>$.view.fn <em>-&gt; Object</em></h2>

<p>Methods that will be available to all instances of all view classes.</p>

<pre><code>$.view.fn.myMethod = function(){
  return this.get(&#39;key&#39;);
};
MyClass = $.view(function(){});
var instance = new MyClass({
  key: &#39;value&#39;
});
instance.myMethod(); //returns &quot;value&quot;</code></pre>

<h2 id='viewclassmethods__object'>$.view.classMethods <em>-&gt; Object</em></h2>

<p>Methods that are available to all view classes.</p>

<pre><code>$.view.classMethods.myClassMethod = function(){};
MyClass = $.view(function(){});
MyClass.myClassMethod();</code></pre>

<h2 id='viewlogging__boolean'>$.view.logging <em>-&gt; Boolean</em></h2>

<p>Set this to true to have view classes output console.log messages.</p>

<h1 id='routes'>Routes</h1>

<p>Maps urls to method calls and method calls to urls. This enables back button support, deep linking and allows methods to be called by normal links (A tags) in your application without adding event handlers or additional code to each link.</p>

<pre><code>$.routes({
  &quot;/&quot;: &quot;PageView#home&quot;,
  &quot;/article/:id&quot;: &quot;ArticlesView#article&quot;
});

//PageView.instance().home() automatically called 

$.routes(&quot;set&quot;,&quot;/article/5&quot;);
//ArticlesView.instance().article({id:5}) automatically called

ArticlesView.instance().article({id:6});
//$.routes(&quot;set&quot;,&quot;/article/6&quot;); automatically called</code></pre>

<h2 id='routesobject_routes_boolean_lazy_loading__false__null'>$.routes(Object routes [,Boolean lazy_loading = false]) -&gt; null</h2>

<p>Calling routes will start routes in your appliction, dispatching the current address present in the url bar of the browser. If no address is present on the page <strong>$.routes(&#8220;set&#8221;,&#8221;/&#8221;)</strong> will automatically be called.</p>

<p>Setting <strong>lazy_loading</strong> to true will prevent your callbacks from being setup for to automatically set the path and will prevent <strong>instance</strong> from being called on each specified object. This is useful in large applications where you do not want all views with routes initialized when $.routes starts. You can manually setup each callback using <strong>$.routes(&#8220;setup&#8221;,callback)</strong></p>

<pre><code>$.routes({
  &quot;/&quot;: &quot;PageView#home&quot;,
  &quot;/article/:id&quot;: &quot;ArticlesView#article&quot;,
  &quot;/about/(:page_name)&quot;: &quot;PageView#page&quot;,
  &quot;/wiki/*&quot;: &quot;WikiView#page&quot;,
  &quot;/class_method&quot;: &quot;Object.method&quot;,
  &quot;/callback&quot;: function(){}
});</code></pre>

<p>Supported types of paths:</p>

<ul>
<li>&#8221;/&#8221; - A plain path with no parameters.</li>

<li>&#8220;/article/:id&#8221; - A path with a required named parameter.</li>

<li>&#8220;/about/(:page_name)&#8221; - A path with an optional named paramter.</li>

<li>&#8220;/wiki/*&#8221; - A path with an asterix / wildcard.</li>
</ul>

<p>Supported types of callbacks:</p>

<ul>
<li>&#8220;PageView#home&#8221; - Will call PageView.instance().home()</li>

<li>&#8220;Object.method&#8221; - Will call Object.method()</li>

<li>function(){} - Will call the specified function.</li>
</ul>

<h2 id='routesurl_string_callback_object_params__string'>$.routes(&#8220;url&#8221;<em>, String callback [,Object params]</em>) <em>-&gt; String</em></h2>

<p>Generates a url for a route.</p>

<pre><code>var url = $.routes(&quot;url&quot;,&quot;ArticlesView#article&quot;,{id:5});
url == &quot;/article/5&quot;</code></pre>

<h2 id='routesget__string'>$.routes(&#8220;get&#8221;) <em>-&gt; String</em></h2>

<p>Returns the current address / path.</p>

<h2 id='routesset__null'>$.routes(&#8220;set&#8221;) <em>-&gt; null</em></h2>

<p>Sets the current address / path, calling the matched route if a match is found.</p>

<pre><code>$.routes(&quot;set&quot;,&quot;/article/5&quot;);</code></pre>

<h2 id='routesadd_string_path_string_callback__null'>$.routes(&#8220;add&#8221;<em>, String path, String callback</em>) <em>-&gt; null</em></h2>

<p>Add a new route.</p>

<pre><code>$.routes(&quot;add&quot;,&quot;/article/:id&quot;,&quot;ArticlesView#article&quot;);</code></pre>

<h2 id='routesmatch_string_path__array_function_callback_object_params'>$.routes(&#8220;match&#8221;<em>, String path</em>) <em>-&gt; Array [Function callback, Object params]</em></h2>

<pre><code>var match = $.routes(&quot;match&quot;,&quot;/article/5&quot;);
match[0](match[1]);</code></pre>

<h2 id='routessetup_string_callback__null'>$.routes(&#8220;setup&#8221;<em>, String callback</em>) <em>-&gt; null</em></h2>

<p>If lazy loading is enabled each callback will need to be setup to enable two way routing.</p>

<pre><code>$.routes(&quot;setup&quot;,&quot;ArticlesView#article&quot;);
ArticlesView.instance().article({id:5});
$.routes(&quot;get&quot;) == &quot;/article/5&quot;</code></pre>

<h2 id='routesstop__null'>$.routes(&#8220;stop&#8221;) <em>-&gt; null</em></h2>

<p>Stops the routing plugin from handling changes in the page address.</p>

<h2 id='routesstart__null'>$.routes(&#8220;start&#8221;) <em>-&gt; null</em></h2>

<p>Called implicitly when you specify your routes. Only necessary if <strong>stop</strong> has been called.</p>

<h2 id='routesdispatcher__function'>$.routes.dispatcher <em>-&gt; Function</em></h2>

<p>The <strong>dispatcher</strong> property is a function invoked each time the route / path changes. It is called with Function callback, Object params, String path. The default dispatcher calls the callback with the params.</p>

<pre><code>$.routes.dispatcher = function(callback,params,path){
  callback(params);
};</code></pre>

<h2 id='routeshistory__array'>$.routes.history <em>-&gt; Array</em></h2>

<p>The history array contains a list of dispatched routes since $.routes was initialized. Each item in the array is an array containing [String path,Function callback,Object params]</p>

<h1 id='builder'>Builder</h1>

<p><strong>$.builder</strong> methods (<strong>div</strong>,<strong>h3</strong>,etc) are usually accessed from within a view class, but are also available staticly:</p>

<pre><code>$.builder.ul(
  $.builder.li(&#39;List item one&#39;)
);</code></pre>

<h2 id='builderexport_object_target__null'>$.builder(&#8220;export&#8221;<em>, Object target</em>) <em>-&gt; null</em></h2>

<p>Copies all tag methods to the target object. By default tag methods are exported to <strong>$.builder</strong> and <strong>$.view.fn</strong></p>

<pre><code>$.builder(&quot;export&quot;,MyObject);
MyObject.div({id:&#39;test&#39;});</code></pre>

<h2 id='builderremove_object_target__null'>$.builder(&#8220;remove&#8221;<em>, Object target</em>) <em>-&gt; null</em></h2>

<p>Removes all tag methods from the target object that were copied from a call to <strong>$.builder(&#8220;export&#8221;,target)</strong></p>
        </body>
      </html>
