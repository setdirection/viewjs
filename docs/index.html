<!DOCTYPE html>
<html>
  <head>
    <title>jQuery View: Markup as JavaScript</title>
    <link type="text/css" rel="stylesheet" href="stylesheets/syntax.css"/>
    <link type="text/css" rel="stylesheet" href="stylesheets/screen.css"/>
    <script type="text/javascript" src="javascripts/jquery.js"></script>
    <script type="text/javascript" src="javascripts/jquery.address.js"></script>
    <script type="text/javascript" src="javascripts/jquery.routes.js"></script>
    <script type="text/javascript" src="javascripts/syntax.js"></script>
    <script type="text/javascript" src="javascripts/docs.js"></script>    
  </head>
  <body>
    <div id="content">
      <div id="main">
        <h1 id='jquery_view'>jQuery View</h1>

<p>Markup as JavaScript <strong><a href='https://github.com/syntacticx/viewjs/zipball/master'>Development</a> | <a href='https://github.com/syntacticx/viewjs/raw/master/jquery.view.min.js'>Production (6KB)</a></strong></p>
<ul id='nav'>
  <li><a href='#intro'>Intro</a></li>
  <li><a href='#guide'>Guide</a></li>
  <li><a href='#api'>API</a></li>
  <li><a href='#examples'>Examples</a></li>
</ul><br class='clear' />
<p>jQuery View provides a class and inheritance system for templates which can be constructed with a mix of pure JavaScript, HTML strings, jQuery templates and jQuery objects:</p>

<pre><code>ListView = $.view(function(){
  return this.ul( //pure JavaScript
    &quot;&lt;li&gt;Item One&lt;/li&gt;&quot;, //HTML strings
    &quot;&lt;li&gt;${key}&lt;/li&gt;&quot;, //jQuery Templates
    $(this.li(&#39;Item Three&#39;)).click(this.handleClick) //inline jQuery
  );
},{
  //methods are auto proxied, &quot;this&quot; is always the view
  handleClick: function(event){}
});
//use views as arguments to jQuery
var instance = new ListView({key:&#39;Item Two&#39;});
$(instance).appendTo(&#39;body&#39;);</code></pre>

<h2 id='works_well_with'>Works Well With</h2>

<ul>
<li><a href='http://routesjs.com/'>jQuery Routes</a></li>

<li><a href='http://documentcloud.github.com/backbone/'>Backbone.js</a> for models and collections</li>
</ul>

<p>Copyright 2011 <a href='http://syntacticx.com/'>Syntacticx</a>. Released under the <a href='http://jquery.org/license'>MIT or GPL License</a>.<br />Thanks to <a href='http://www.youtube.com/watch?v=lwDDa9ctNFE'>_why</a> for <a href='http://markaby.github.com/'>Markaby</a>.</p>

<h2 id='class_creation'>Class Creation</h2>

<p>Use $.view to create a new View class. $.view takes two arguments, a constructor function that must return a DOM element or HTML string, and an optional hash of instance methods.</p>

<pre><code>MyView = $.view(function(){
  return this.div();
},{
  methodName: function(){}
});</code></pre>

<p>The constructor may also be specified as &#8220;initialize&#8221;:</p>

<pre><code>MyView = $.view({
  initialize: function(){
    return this.div();
  }
});</code></pre>

<p>The element returned by the constructor is available via the <strong>element</strong> method. Passing a View instance to jQuery is the same as passing the View&#8217;s element to jQuery.</p>

<pre><code>var instance = new MyView();
instance.element().tagName == &#39;DIV&#39;;
$(instance).appendTo(document.body);</code></pre>

<p>All instance methods specified are automatically proxied, so you can pass an instance method as an event handler and &#8220;this&#8221; will still refer to the view instance.</p>

<pre><code>$(&#39;&lt;a href=&quot;#&quot;&gt;My Link&lt;/a&gt;&#39;).click(this.handleClick);</code></pre>

<p>A View class may optionally attach to an Element that is already on the page, in which case the constructor must always be called with an Element:</p>

<pre><code>MyView = $.view(function(element){});
new MyView($(&#39;#my_div&#39;),{key:&#39;value&#39;});</code></pre>

<h3 id='attributes'>Attributes</h3>

<p>View classes take only one argument when creating a new instance: an optional hash of attributes. Attributes are accessed using <strong>get</strong>, <strong>set</strong>, and <strong>attributes</strong> which will return a plain hash of the View&#8217;s attributes.</p>

<pre><code>var instance = new MyView({
  key: &#39;value&#39;
});
instance.get(&#39;key&#39;);
instance.attributes();</code></pre>

<h3 id='subclasses'>Subclasses</h3>

<p>Views can be subclassed by passing a View class as the first argument to <strong>$.view</strong>. The constructor will receive the parent&#8217;s element as the only argument. The constructor does not need to return an element since the parent&#8217;s constructor has already generated it. Any events bound to the parent class will be triggered on the child class.</p>

<pre><code>MyViewSubclass = $.view(MyView,function(element){
  $(element).addClass(&#39;two&#39;);
  this.ready(function(){
    //do something special only in this subclass
  });
},{
  childMethod: function(){}
});</code></pre>

<p>A subclass constructor may <strong>optionally</strong> return an element. In this case the subclass will return the parent&#8217;s p tag wrapped in a div.</p>

<pre><code>ParagraphView = $.view(function(){
  return this.p(this.get(&#39;text&#39;));
});

EnhancedParagraphView = $.view(ParagraphView,function(element){
  return this.div({className:&#39;enhanced&#39;},element);
});</code></pre>

<h3 id='singletons'>Singletons</h3>

<p>View classes implement a variant of the <a href='http://en.wikipedia.org/wiki/Singleton_pattern'>Singleton pattern</a> with the <strong>instance</strong> method. This method will return the same instance of a view every time it is called, or will create it if <strong>instance</strong> is being called for the first time on that class.</p>

<pre><code>var instance = MyView.instance();</code></pre>

<h2 id='builder'>Builder</h2>

<p>All HTML tag names are available as methods inside of View classes. Each view method takes a variable number of arguments which can be passed in any order and returns a DOM element. Possible arguments are: A hash of HTML attributes:</p>

<pre><code>this.a({href:&#39;#&#39;,className:&#39;my_link&#39;});</code></pre>

<p>A string:</p>

<pre><code>this.p(&#39;Paragraph text.&#39;);</code></pre>

<p>DOM Elements:</p>

<pre><code>this.ul({className:&#39;my_list&#39;},
  this.li(&#39;Item One&#39;)
  this.li(this.b(&#39;Bold List Item Two&#39;))
);</code></pre>

<p>HTML strings can be mixed and matched:</p>

<pre><code>this.form(
  &#39;&lt;p class=&quot;label&quot;&gt;Author&lt;/p&gt;&#39;,
  this.input({name:&#39;author&#39;,type:&#39;text&#39;}),
  this.p({className:&#39;label&#39;},&#39;Body &lt;b&gt;Required&lt;/b&gt;&#39;),
  &#39;&lt;textarea name=&quot;body&quot;&gt;&lt;/textarea&gt;&#39;
);</code></pre>

<p>Templates will be rendered with the view&#8217;s attributes and methods:</p>

<pre><code>MyView = $.view(function(){
  this.set(&#39;key&#39;,&#39;value&#39;);
  this.ul(
    &#39;&lt;li&gt;${key}&lt;/li&gt;&#39;
  );
});</code></pre>

<p>jQuery objects can be used. Any instance methods defined by the class will automatically be proxied, so &#8220;this&#8221; will always refer to the view instance if passed to an event handler.</p>

<pre><code>MyView = $.view(function(){
  return this.ul(
    this.li(
      $(this.a({href:&#39;#&#39;},&#39;My Link&#39;)).click(this.handleClick)
    )
  );
},{
  handleClick: function(event){
    //this == MyView instance
    var element = event.target;
    return false;
  }
});</code></pre>

<p>Methods will be called:</p>

<pre><code>this.ul(this.generateListItems);</code></pre>

<p>View classes and view instances:</p>

<pre><code>this.ul(
  this.li(&#39;Item Two&#39;),
  ListItemView, //will be initialized with no attributes
  new ListItemView({name:&#39;Item Three&#39;})
);</code></pre>

<p>An array (which will be flattened) of any of the above can be used as well:</p>

<pre><code>this.ul(
  this.li(&#39;Item One&#39;),
  [
    this.li(&#39;Item Two&#39;),
    this.li(&#39;Item Three&#39;),
    [
      this.li(&#39;Item Four&#39;)
    ]
  ]
);</code></pre>

<p>The <strong>map</strong> method returns an Array and is designed to be used with builder methods. It accepts an array or object. &#8220;this&#8221; will always refer to the view instance inside of the iterator.</p>

<pre><code>this.ul(
  this.map([&#39;One&#39;,&#39;Two&#39;,&#39;Three&#39;],function(item,i){
    return this.li(&#39;Item &#39; + item);
  })
);
this.ul(
  this.map({
    &#39;jQuery&#39;: &#39;http://jquery.com/&#39;,
    &#39;NodeJS&#39;: &#39;http://nodejs.org/&#39;
  },function(key,value){
    return this.li(this.a({href:value},key));
  })
);</code></pre>

<p>Builder methods are also available in the <strong>$.view</strong> object if builder methods are needed outside of view classes:</p>

<pre><code>MyView.classMethod = function(){
  return $.view.div();
};</code></pre>

<p>References to elements can be assigned as you build your elements. This saves writing a query to find a particular element you need later.</p>

<pre><code>this.ul(
  this.listItemOne = this.li(),
  this.li()
);
$(this.listItemOne).click(this.clickHandler);</code></pre>

<h2 id='events'>Events</h2>

<p>Each View class has the same event method names as jQuery: <strong>bind</strong>, <strong>unbind</strong>, <strong>one</strong>, <strong>trigger</strong>. View events are not DOM events, there is no event object and an arbitrary number of arguments can be passed to event handlers. Events should be the primary way multiple View&#8217;s communicate with each other.</p>

<p>Events are created with the <strong>trigger</strong> method. All arguments passed to trigger are passed to any registered event handlers. If any event handler returns false, the call to <strong>trigger</strong> will return false. Otherwise it will return an array of responses from the handlers.</p>

<pre><code>this.trigger(&#39;event_name&#39;,a,b);</code></pre>

<p>Events can be observed on all instances of a class. Handlers will receive the instance that triggered the event followed by any arguments passed in the event.</p>

<pre><code>MyView.bind(&#39;event_name&#39;,function(instance,a,b){

});</code></pre>

<p>View&#8217;s <strong>bind</strong> method accepts an optional context parameter. Any arguments after that will be curried onto the handler.</p>

<pre><code>this.bind(&#39;event_name&#39;,function(c,a,b){
  this == context;
},context,c);</code></pre>

<p>View classes have two built in events. The <strong>ready</strong> event is triggered when the View&#8217;s element has been attached to the DOM. It can be accessed by the <strong>ready</strong> method or by calling <strong>bind(&#8216;ready&#8217;,handler)</strong>.</p>

<pre><code>MyView = $.view(function(){
  this.ready(function(){
    this.nameInput.focus();
  });
  return this.form(
    this.p({className:&#39;label&#39;,&#39;Name&#39;}),
    this.nameInput = this.input({type:&#39;text&#39;})
  );
});</code></pre>

<p>The <strong>change</strong> event is triggered whenever attributes in the view have been changed.</p>

<pre><code>MyView.bind(&#39;change&#39;,function(instance,changed_attributes){
  for(var key in changed_attributes){
    
  }
});</code></pre>

<h2 id='class'>Class</h2>

<h3 id='viewobject_methods__classviewclass_parent_object_methods_classviewfunction_constructor_object_methods__classviewclass_parent_functionelement_object_methods__class'>$.view<em>(Object methods) -&gt; Class</em><br />$.view<em>(Class parent, Object methods) -&gt;Class</em><br />$.view<em>(Function constructor [,Object methods]) -&gt; Class</em><br />$.view<em>(Class parent, Function(Element) [,Object methods]) -&gt; Class</em></h3>

<p>Create a new View class:</p>

<pre><code>MyView = $.view(function(){
  return this.div();
},{
  methodName: function(){}
});</code></pre>

<p>The constructor can also be specified via the &#8220;initialize&#8221; method:</p>

<pre><code>MyView = $.view({
  initialize: function(){
    return this.div();
  },
  methodName: function(){}
});</code></pre>

<p>Or subclass an existing View class:</p>

<pre><code>MyViewTwo = $.view(MyView,function(element){
  $(element).addClass(&#39;special&#39;);
},{
  childMethod: function(){}
});</code></pre>

<p>A View class may optionally attach to an Element that is already on the page, in which case the constructor must always be called with an Element:</p>

<pre><code>MyView = $.view(function(element){});
new MyView($(&#39;#my_div&#39;),{key:&#39;value&#39;});</code></pre>

<h3 id='new_classobject_attributes__instancenew_classelement_object_attributes__instance'>new Class<em>([Object attributes]) -&gt; instance</em><br />new Class<em>(Element [,Object attributes]) -&gt; instance</em></h3>

<p>Creates a new instance of a View class.</p>

<pre><code>var instance = new MyView({
  key: &#39;value&#39;
});
instance.get(&#39;key&#39;) == &#39;value&#39;;
$(instance).appendTo(document.body);</code></pre>

<p>Views may optionally attach to an element that is already in the DOM, in which case they require an Element or jQuery object as the first argument, which the constructor will receive:</p>

<pre><code>MyView = $.view(function(element){});
new MyView($(&#39;#my_div&#39;),{key:&#39;value&#39;});</code></pre>

<h3 id='classinstance__instance'>Class.instance<em>() -&gt; instance</em></h3>

<p>Get an instance of the View class. <strong>instance</strong> will create a new instance the first time it is invoked, and will return the same instance on subsequent calls.</p>

<pre><code>var instance = MyView.instance();
instance == MyView.instance();</code></pre>

<h2 id='core'>Core</h2>

<h3 id='instanceelement__elementinstanceelementelement_element__element'>instance.element<em>() -&gt; Element</em><br />instance.element<em>(Element element) -&gt; Element</em></h3>

<p>Get the outermost element of the view, which is returned by the constructor.</p>

<pre><code>var instance = new MyView();
instance.element().tagName == &#39;DIV&#39;</code></pre>

<p>You can explicitly set the element in the constructor using this method instead of reutrning an Element from the constructor.</p>

<pre><code>MyView = $.view(function(){
  this.element(this.div());
  $(this.element()).addClass(&#39;my_div&#39;);
});</code></pre>

<h3 id='instanceattributes__objectinstanceattributesobject_attributes_boolean_silent__false__object'>instance.attributes<em>() -&gt; Object</em><br />instance.attributes<em>(Object attributes [,Boolean silent = false]) -&gt; Object</em></h3>

<p>Get a hash of attributes in the view.</p>

<pre><code>var instance = new MyView({key:&#39;value&#39;});
instance.attributes() == {key:&#39;value&#39;};</code></pre>

<p>Or set all attributes in the view. Attributes that are present in the view but not in the passed object will be removed. Set <strong>silent</strong> to true to prevent the <strong>change</strong> event from being triggered.</p>

<pre><code>instance.bind(&#39;change&#39;,function(changed_attributes){
   for(var key in changed_attributes){
     
   }
});
instance.attributes({key:&#39;value&#39;});</code></pre>

<h3 id='instancegetstring_key__mixedinstancegetarray_keys__arrayinstancegetstring_key_string_key__array'>instance.get<em>(String key) -&gt; mixed</em><br />instance.get<em>(Array keys) -&gt; Array</em><br />instance.get<em>(String key [,String key&#8230;]) -&gt; Array</em><br /></h3>

<p>Get an attribute from the view.</p>

<pre><code>var instance = new MyView({key:&#39;value&#39;});
instance.get(&#39;key&#39;) == &#39;value&#39;;</code></pre>

<p>Or get an array of attributes:</p>

<pre><code>instance.get(&#39;a&#39;,&#39;b&#39;);
instance.get([&#39;a&#39;,&#39;b&#39;]);</code></pre>

<h3 id='instancesetstring_key_mixed_value_boolean_silent__false__mixedinstancesetobject_attributes_boolean_silent__false__object'>instance.set<em>(String key, mixed value [,Boolean silent = false]) -&gt; mixed</em><br />instance.set<em>(Object attributes [,Boolean silent = false]) -&gt; Object</em></h3>

<p>Set an attribute in the view. This will trigger the <strong>change</strong> event. Set <strong>silent</strong> to true to prevent the <strong>change</strong> event from firing.</p>

<pre><code>var instance = new MyView();
instance.bind(&#39;change&#39;,function(changed_attributes){
  for(var key in changed_attributes){
  
  }
});
instance.set(&#39;key&#39;,&#39;value&#39;);</code></pre>

<p>An object can also be passed to set multiple values:</p>

<pre><code>instance.set({
  key: &#39;value&#39;
});</code></pre>

<h3 id='instancetagstring_text_element_object_attributes__element'>instance.tag<em>([String text] [,Element] [,Object attributes]&#8230;) -&gt; Element</em></h3>

<p><strong>tag</strong> refers to any HTML tag name and is used to create DOM elements. Tag takes an arbitrary number of arguments in any order which can be:</p>

<ul>
<li>string or number</li>

<li>HTML string</li>

<li>Template string</li>

<li>hash of HTML attributes</li>

<li>DOM Element</li>

<li>jQuery Object</li>

<li>View Class</li>

<li>View instance</li>

<li>Function to be called</li>

<li>Array of any of the above</li>
</ul>

<p>Sample usage:</p>

<pre><code>this.ul({className:&#39;my_list&#39;},
  this.li(&#39;Item One&#39;),
  this.li(&#39;Item Two&#39;),
  $(this.li(&#39;Item Three&#39;)).click(),
  &#39;&lt;li&gt;Item Four&lt;/li&gt;&#39;
)</code></pre>

<h2 id='events'>Events</h2>

<h3 id='instancebindobject_events__objectinstancebindstring_event_name_function_handler_object_context__function'>instance.bind<em>(Object events) -&gt; Object</em><br />instance.bind<em>(String event_name, Function handler [,Object context]) -&gt; Function</em></h3>

<p>Register a handler for an event on a given instance. &#8220;this&#8221; will refer to the view instance unless a <strong>context</strong> argument was passed.</p>

<pre><code>instance.bind(&#39;event_name&#39;,function(a,b,c){
  
});</code></pre>

<p>You can register an event handler on all instances of a class by calling <strong>bind</strong> on the class. The handler will receive the instance that triggered the event as the first argument, followed by any other arguments passed by <strong>trigger</strong>.</p>

<pre><code>MyView.bind(&#39;event_name&#39;,function(instance,a,b,c){
  
});</code></pre>

<p>Multiple handlers can be registered at once by passing a hash:</p>

<pre><code>instance.bind({
  event_name: function(a,b,c){}
});</code></pre>

<h3 id='instanceunbindstring_event_name_function_handler__null'>instance.unbind<em>([String event_name] [,Function handler]) -&gt; null</em></h3>

<p>unbind an event handler registered on a given instance.</p>

<pre><code>instance.unbind(&#39;event_name&#39;,handler);</code></pre>

<p>Any event handlers that were registered on the class can be unbound by calling Class.unbind:</p>

<pre><code>MyView.unbind(&#39;event_name&#39;,handler);</code></pre>

<h3 id='instanceonestring_event_name_function_handler_object_context__function'>instance.one<em>(String event_name, Function handler [,Object context]) -&gt; Function</em></h3>

<p>This method is identical to <strong>bind</strong>, except that the handler is unbound after its first invocation.</p>

<pre><code>instance.one(&#39;event_name&#39;,function(){
  //only called once
});</code></pre>

<h3 id='instancetriggerstring_event_name_mixed_arg__array_or_false'>instance.trigger<em>(String event_name [,mixed arg&#8230;]) -&gt; Array or false</em></h3>

<p>Triggers the given event, passing an arbitrary number of arguments to the handlers. Returns an array of responses, or false if a handler stopped the event by returning false.</p>

<pre><code>instance.trigger(&#39;event_name&#39;,a,b,c);</code></pre>

<p><strong>instance.trigger</strong> will notify all handlers bound by <strong>instance.bind</strong> and <strong>Class.bind</strong>. Calling <strong>Class.trigger</strong> will only notify handlers bound by <strong>Class.bind</strong>.</p>

<pre><code>instance.bind(&#39;event_name&#39;,handler); //not called by Class.trigger
MyView.bind(&#39;event_name&#39;,handler); //called by Class.trigger
MyView.trigger(&#39;event_name&#39;);</code></pre>

<h3 id='instancereadyfunction_handler_object_context__function'>instance.ready<em>(Function handler [,Object context]) -&gt; Function</em></h3>

<p>Identical to calling <strong>instance.bind(&#8216;ready&#8217;,handler)</strong> The <strong>ready</strong> event is triggered when the view&#8217;s outermost element is attached to the DOM. &#8220;this&#8221; will always refer to the view instance unless a <strong>context</strong> argument was passed.</p>

<pre><code>instance.ready(function(){
  $(&#39;input:first&#39;,this).focus();
});</code></pre>

<p>Calling <strong>ready</strong> on the class will observe the <strong>ready</strong> event of all instances.</p>

<pre><code>MyView.ready(function(instance){
  $(&#39;input:first&#39;,instance).focus();
});</code></pre>

<h3 id='instanceemitevent_name_mixed_arg__function'>instance.emit<em>(event_name [,mixed arg&#8230;]) -&gt; Function</em></h3>

<p>Creates a callback that will trigger event_name with the supplied arguments.</p>

<pre><code>this.bind(&#39;event_name&#39;,function(a,b,c){});
$(link).click(this.emit(&#39;event_name&#39;,a,b,c));</code></pre>

<h2 id='helpers'>Helpers</h2>

<h3 id='instancemaparray_functionitemindex__arrayinstancemapobject_functionkeyvalueindex__arrayinstancemapstring_key_of_array_functionitemindex__arrayinstancemapstring_key_of_object_functionkeyvalueindex__array'>instance.map<em>(Array, Function(item,index)) -&gt; Array</em><br />instance.map<em>(Object, Function(key,value,index)) -&gt; Array</em><br />instance.map<em>(String key_of_array, Function(item,index)) -&gt; Array</em><br />instance.map<em>(String key_of_object, Function(key,value,index)) -&gt; Array</em></h3>

<p>Similar to Array#map or Ruby&#8217;s Array#collect. Works on objects or Arrays. If an object is passed the iterator will be called with (key,value), if an Array is passed the iterator will be called with (value,index). Inside the iterator &#8220;this&#8221; will always refer to the view instance.</p>

<pre><code>var NavigationView = $.view(function(){
  return this.ul(this.map({
    &#39;Page Title&#39;: &#39;http://page.com/&#39;
  },function(title,url,i){
    return this.li(
      this.a({href:url},title)
    );
  }));
});</code></pre>

<p>Passing a string key is the same as passing this.get(key) to <strong>map</strong>:</p>

<pre><code>this.map(&#39;links&#39;,function(link){});
//equivalent to:
this.map(this.get(&#39;links&#39;),function(link){});</code></pre>

<p>A hash of keys and callbacks can also be passed:</p>

<pre><code>this.map({
  an_array: function(item,index){},
  an_object: function(key,value,index){}
})</code></pre>

<h3 id='instancecallbackstring_method_mixed_arg__function'>instance.callback<em>(String method, [mixed arg&#8230;]) -&gt; Function</em></h3>

<p>Creates a callback function which will call the method with the supplied arguments.</p>

<pre><code>MyView = $.view(function(){
  return this.ul(
    this.map([1,2,3],function(i){
      return this.li(
        $(this.a({href:&#39;#&#39;})).click(this.callback(&#39;handleClick&#39;,i))
      );
    })
  );
},{
  handleClick: function(i){}
});</code></pre>

<h3 id='instancedelegatestring_selector_string_event_name_function_callback_object_context__null'>instance.delegate<em>(String selector, String event_name, Function callback [,Object context]) -&gt; null</em></h3>

<p>Equivelent to calling <a href='http://api.jquery.com/delegate/'>jQuery&#8217;s delegate</a> method, but can be called before the view&#8217;s element has been created.</p>

<pre><code>MyView = $.view(function(){
  this.delegate(&#39;a&#39;,&#39;click&#39;,this.handleClick);
  return this.ul(
    this.li(this.a({href:&#39;#&#39;},&#39;Link One&#39;)),
    this.li(this.a({href:&#39;#&#39;},&#39;Link Two&#39;))
  );
},{
  handleClick: function(){}
});</code></pre>

<h3 id='instanceescapestring_unescaped__string'>instance.escape<em>(String unescaped) -&gt; String</em></h3>

<p>Prevent HTML or template strings from being interpreted.</p>

<pre><code>this.p(this.escape(&#39;Will not be processed ${key}&#39;));
this.p(this.escape(&#39;&lt;b&gt;Will appear as text.&lt;/b&gt;&#39;));</code></pre>

<h3 id='instance__object__function'>instance.$ <em>-&gt; Object | Function</em></h3>

<p>A hybrid jQuery object for the current view&#8217;s element that also acts as a selector function scoped to the current view&#8217;s element.</p>

<pre><code>//adds &quot;active&quot; class to view&#39;s element
this.$.addClass(&#39;active&#39;);
//selects all spans inside the view&#39;s element
this.$(&#39;span&#39;);</code></pre>

<h2 id='templates'>Templates</h2>

<h3 id='instancetemplate__string'>instance.template <em>-&gt; String</em></h3>

<p>Specify a string template in this property if you want it to be available via the <strong>element</strong> method before the constructor is called. Also convenient when using CoffeeScript&#8217;s multiline strings.</p>

<pre><code>MyView = $.view({
  template: &quot;&lt;p&gt;&lt;/p&gt;&quot;,
  initialize: function(element){
    $(element).addClass(&#39;best_paragraph_ever&#39;);
  }
});</code></pre>

<h3 id='instancerenderstring_template_object_attributes__string'>instance.render<em>(String template [,Object attributes]) -&gt; String</em></h3>

<p>Render a string with the current template engine.</p>

<pre><code>this.set(&#39;key&#39;,&#39;value&#39;);
this.render(&#39;&lt;li&gt;${key}&lt;/li&gt;&#39;);</code></pre>

<h3 id='classengine__stringclassenginestring_engine__nullviewengineobject_engine__nullviewenginestring_engine__null'>Class.engine<em>() -&gt; String</em><br />Class.engine<em>(String engine) -&gt; null</em><br />$.view(&#8216;engine&#8217;<em>,Object engine) -&gt; null</em><br />$.view(&#8216;engine&#8217;<em>,String engine) -&gt; null</em></h3>

<p>Get or set the current template engine per class.</p>

<pre><code>MyView = $.view(function(){
  return &quot;&lt;p&gt;{{key}}&lt;/p&gt;&quot;;
});
MyView.engine(&#39;mustache&#39;);
MyView.engine() == &#39;mustache&#39;;</code></pre>

<p>To register a new engine, call $.view with &#8216;engine&#8217; and an object containing <strong>name</strong>, <strong>detect</strong> and <strong>render</strong>. The official jQuery Template plugin is the default engine, and ships with jQuery View as &#8220;jquery.tmpl&#8221;. The following code would register Mustache as a valid engine:</p>

<pre><code>$.view(&#39;engine&#39;,{
  name: &#39;mustache&#39;,
  detect: function(string){
    return string.match(/\{\{[^\}]+\}\}/);
  },
  render: function(string,attributes){
    return Mustache.to_html(string,attributes);
  }
});</code></pre>

<p>Registering a new engine will set that engine as the default on all classes unless the class specifies it&#8217;s engine with <strong>Class.engine(engine)</strong>. To change the default:</p>

<pre><code>$.view(&#39;engine&#39;,&#39;jquery.tmpl&#39;);</code></pre>

<h2 id='properties'>Properties</h2>

<h3 id='viewclassmethods__object'>$.view.classMethods <em>-&gt; Object</em></h3>

<p>Methods that are available to all view classes.</p>

<pre><code>$.view.classMethods.myClassMethod = function(){};
MyClass = $.view(function(){});
MyClass.myClassMethod();</code></pre>

<h3 id='viewlogging__boolean'>$.view.logging <em>-&gt; Boolean</em></h3>

<p>Set this to true to have view classes output console.log messages.</p>

<h3 id='viewfn__object'>$.view.fn <em>-&gt; Object</em></h3>

<p>Methods that will be available to all instances of all view classes.</p>

<pre><code>$.view.fn.myMethod = function(){
  return this.get(&#39;key&#39;);
};
MyClass = $.view(function(){});
var instance = new MyClass({
  key: &#39;value&#39;
});
instance.myMethod(); //returns &quot;value&quot;</code></pre>

<h2 id='examples'>Examples</h2>

<ul>
<li><strong><a href='http://viewjs.com/examples/todos/index.html'>Local Todos</a></strong> (<a href='http://viewjs.com/examples/todos/todos.html'>Annotated Source</a>)</li>

<li><strong><a href='http://syntacticx.com/photos/'>PhotoFolder</a></strong> (<a href='http://photofolder.org/'>Annotated Source</a>)</li>
</ul>
      </div>
      <div id="api_toc">
        <table>
          <tbody>
            <tr>
              <td>
                <h2>Class</h2><h3>- <a href="#viewobject_methods__classviewclass_parent_object_methods_classviewfunction_constructor_object_methods__classviewclass_parent_functionelement_object_methods__class">$.view</a></h3><h3>- <a href="#new_classobject_attributes__instancenew_classelement_object_attributes__instance">new Class</a></h3><h3>- <a href="#classinstance__instance">instance</a></h3></td><td><h2>Core</h2><h3>- <a href="#instanceelement__elementinstanceelementelement_element__element">element</a></h3><h3>- <a href="#instanceattributes__objectinstanceattributesobject_attributes_boolean_silent__false__object">attributes</a></h3><h3>- <a href="#instancegetstring_key__mixedinstancegetarray_keys__arrayinstancegetstring_key_string_key__array">get</a></h3><h3>- <a href="#instancesetstring_key_mixed_value_boolean_silent__false__mixedinstancesetobject_attributes_boolean_silent__false__object">set</a></h3><h3>- <a href="#instancetagstring_text_element_object_attributes__element">tag</a></h3></td><td><h2>Events</h2><h3>- <a href="#instancebindobject_events__objectinstancebindstring_event_name_function_handler_object_context__function">bind</a></h3><h3>- <a href="#instanceunbindstring_event_name_function_handler__null">unbind</a></h3><h3>- <a href="#instanceonestring_event_name_function_handler_object_context__function">one</a></h3><h3>- <a href="#instancetriggerstring_event_name_mixed_arg__array_or_false">trigger</a></h3><h3>- <a href="#instancereadyfunction_handler_object_context__function">ready</a></h3><h3>- <a href="#instanceemitevent_name_mixed_arg__function">emit</a></h3></td><td><h2>Helpers</h2><h3>- <a href="#instancemaparray_functionitemindex__arrayinstancemapobject_functionkeyvalueindex__arrayinstancemapstring_key_of_array_functionitemindex__arrayinstancemapstring_key_of_object_functionkeyvalueindex__array">map</a></h3><h3>- <a href="#instancecallbackstring_method_mixed_arg__function">callback</a></h3><h3>- <a href="#instancedelegatestring_selector_string_event_name_function_callback_object_context__null">delegate</a></h3><h3>- <a href="#instanceescapestring_unescaped__string">escape</a></h3><h3>- <a href="#instance__object__function">$ </a></h3></td><td><h2>Templates</h2><h3>- <a href="#instancetemplate__string">template </a></h3><h3>- <a href="#instancerenderstring_template_object_attributes__string">render</a></h3><h3>- <a href="#classengine__stringclassenginestring_engine__nullviewengineobject_engine__nullviewenginestring_engine__null">engine</a></h3></td><td><h2>Properties</h2><h3>- <a href="#viewclassmethods__object">classMethods </a></h3><h3>- <a href="#viewlogging__boolean">logging </a></h3><h3>- <a href="#viewfn__object">fn </a></h3></td><td><h2>Examples</h2>
              </td>
            </tr>
           </tbody>
        </table>
        <div id="api_example"></div>
      </div>
    </div>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-20694546-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </body>
</html>
